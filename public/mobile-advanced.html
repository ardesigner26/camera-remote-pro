<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Camera Remote Pro - Mobile Advanced</title>
    <link rel="manifest" href="manifest.json">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#667eea">
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body { 
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #fff;
            padding: 15px;
            min-height: 100vh;
        }
        .container {
            max-width: 600px;
            margin: 0 auto;
            background: rgba(0,0,0,0.8);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.5);
        }
        h1 { text-align: center; margin-bottom: 10px; font-size: 24px; }
        .subtitle {
            text-align: center;
            color: #0f0;
            font-size: 12px;
            margin-bottom: 20px;
        }
        .status-panel {
            background: rgba(255,255,255,0.1);
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
        }
        .status-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 14px;
        }
        .status-value {
            color: #0f0;
            font-weight: bold;
        }
        .video-container {
            width: 100%;
            height: 400px;
            overflow: hidden;
            border-radius: 10px;
            border: 3px solid #0f0;
            margin-bottom: 20px;
            background: #000;
            position: relative;
        }
        video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        .zoom-indicator {
            position: absolute;
            top: 15px;
            right: 15px;
            background: rgba(0,0,0,0.85);
            color: #0f0;
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 18px;
            font-weight: bold;
            border: 2px solid #0f0;
            box-shadow: 0 0 10px rgba(0,255,0,0.3);
        
            display: none; /* Removido para n√£o piscar */}
        .zoom-info {
            position: absolute;
            bottom: 15px;
            left: 15px;
            background: rgba(0,0,0,0.85);
            color: #fff;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 12px;
            border: 1px solid #667eea;
        }
        .config-section {
            background: rgba(255,255,255,0.05);
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 15px;
        }
        .config-title {
            font-size: 16px;
            font-weight: bold;
            margin-bottom: 10px;
            color: #667eea;
        }
        label {
            display: block;
            margin-bottom: 5px;
            font-size: 14px;
        }
        select, input[type="text"], button {
            width: 100%;
            padding: 12px;
            margin-bottom: 15px;
            border: none;
            border-radius: 8px;
            font-size: 16px;
        }
        select, input[type="text"] {
            background: rgba(255,255,255,0.1);
            color: #fff;
            border: 2px solid rgba(255,255,255,0.2);
        }
        select option {
            background: #2a2a2a;
            color: #fff;
        }
        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #fff;
            font-weight: bold;
            cursor: pointer;
            font-size: 18px;
            padding: 15px;
        }
        button:disabled {
            background: #555;
            opacity: 0.5;
        }
        .camera-info {
            background: rgba(0,255,0,0.1);
            padding: 10px;
            border-radius: 8px;
            margin-top: 10px;
            font-size: 12px;
            border: 1px solid #0f0;
        }
        .camera-info.best {
            background: rgba(255,215,0,0.1);
            border-color: #FFD700;
            color: #FFD700;
        }
        .log {
            background: #000;
            color: #0f0;
            padding: 10px;
            border-radius: 8px;
            height: 200px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            margin-top: 15px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üì± CAMERA REMOTE PRO</h1>
        <div class="subtitle">‚úÖ Detec√ß√£o R√°pida + Zoom + Lat√™ncia Zero</div>

        <div class="status-panel">
            <div class="status-row">
                <span>Status:</span>
                <span class="status-value" id="status">Desconectado</span>
            </div>
            <div class="status-row">
                <span>C√¢mera:</span>
                <span class="status-value" id="currentCamera">-</span>
            </div>
            <div class="status-row">
                <span>Resolu√ß√£o:</span>
                <span class="status-value" id="currentResolution">-</span>
            </div>
            <div class="status-row">
                <span>FPS:</span>
                <span class="status-value" id="currentFps">-</span>
            </div>
            <div class="status-row">
                <span>Bitrate:</span>
                <span class="status-value" id="currentBitrate">-</span>
            </div>
            <div class="status-row">
                <span>Zoom:</span>
                <span class="status-value" id="currentZoom">1.0x</span>
            </div>
        </div>

        <div class="video-container">
            <video id="video" autoplay playsinline muted></video>
            <div class="zoom-indicator" id="zoomIndicator">üîç 1.0x</div>
            <div class="zoom-info" id="zoomInfo">Zoom: 1.0x / Max: -</div>
        </div>

        <div class="config-section">
            <div class="config-title">üìπ SELECIONAR C√ÇMERA</div>
            <select id="cameraSelect" disabled>
                <option value="">Detectando...</option>
            </select>
            <div class="camera-info" id="cameraInfo" style="display:none;"></div>
        </div>

        <div class="config-section">
            <div class="config-title">üìê RESOLU√á√ÉO</div>
            <select id="resolutionSelect">
                <option value="640x480">VGA 480p (640x480)</option>
                <option value="1280x720">HD 720p (1280x720)</option>
                <option value="1920x1080" selected>Full HD 1080p (1920x1080)</option>
                <option value="2560x1440">2K QHD (2560x1440)</option>
                <option value="3840x2160">4K UHD (3840x2160)</option>
            </select>
        </div>

        <div class="config-section">
            <div class="config-title">üìä BITRATE</div>
            <select id="bitrateSelect">
                <option value="5000000">5 Mbps</option>
                <option value="10000000" selected>10 Mbps</option>
                <option value="15000000">15 Mbps</option>
                <option value="20000000">20 Mbps</option>
                <option value="25000000">25 Mbps</option>
                <option value="30000000">30 Mbps</option>
                <option value="35000000">35 Mbps</option>
                <option value="40000000">40 Mbps</option>
                <option value="45000000">45 Mbps</option>
                <option value="50000000">50 Mbps</option>
            </select>
        </div>

        <div class="config-section">
            <div class="config-title">üé¨ FPS</div>
            <select id="fpsSelect">
                <option value="15">15 FPS (Ultra Baixa Lat√™ncia)</option>
                <option value="20">20 FPS (Baixa Lat√™ncia)</option>
                <option value="24">24 FPS (M√©dia)</option>
                <option value="30" selected>30 FPS (Mais ou Menos)</option>
                <option value="60">60 FPS (Alta Lat√™ncia)</option>
            </select>
        </div>

        <label>ID da Sala:</label>
        <input type="text" id="roomId" placeholder="Digite o ID da sala">
        
        <button id="startBtn">üöÄ INICIAR</button>
        <button id="restartBtn" style="display:none; background:#f44336;">üîÑ APLICAR MUDAN√áAS</button>

        <div class="log" id="log"></div>
    </div>

    <script src="/socket.io/socket.io.js"></script>
    <script>
        const video = document.getElementById('video');
        const roomIdInput = document.getElementById('roomId');
        const startBtn = document.getElementById('startBtn');
        const restartBtn = document.getElementById('restartBtn');
        const cameraSelect = document.getElementById('cameraSelect');
        const cameraInfo = document.getElementById('cameraInfo');
        const resolutionSelect = document.getElementById('resolutionSelect');
        const bitrateSelect = document.getElementById('bitrateSelect');
        const fpsSelect = document.getElementById('fpsSelect');
        const statusSpan = document.getElementById('status');
        const currentCamera = document.getElementById('currentCamera');
        const currentResolution = document.getElementById('currentResolution');
        const currentFps = document.getElementById('currentFps');
        const currentBitrate = document.getElementById('currentBitrate');
        const currentZoom = document.getElementById('currentZoom');
        const zoomIndicator = document.getElementById('zoomIndicator');
        const zoomInfo = document.getElementById('zoomInfo');
        const logDiv = document.getElementById('log');

        let socket, peerConnection, localStream, roomId, videoTrack, videoSender;
        let zoomMin = 1.0, zoomMax = 10.0, currentZoomLevel = 1.0;
        let bufferDelay = 100;
        let zoomDebounceTimer = null;
        let availableCameras = [];
        let bestCamera = null;
        let selectedCameraId = null;

        const config = { 
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:stun1.l.google.com:19302' }
            ],
            iceTransportPolicy: 'all',
            bundlePolicy: 'max-bundle',
            rtcpMuxPolicy: 'require'
        };

        function log(msg) {
            console.log(msg);
            const timestamp = new Date().toLocaleTimeString();
            logDiv.innerHTML += `[${timestamp}] ${msg}<br>`;
            logDiv.scrollTop = logDiv.scrollHeight;
        }

        function updateStatus(text) {
            statusSpan.textContent = text;
        }

        // üìπ DETEC√á√ÉO R√ÅPIDA (SEM TESTES LENTOS)
        async function detectCameras() {
            log('üîç Detectando c√¢meras...');
            
            try {
                const tempStream = await navigator.mediaDevices.getUserMedia({ video: true });
                tempStream.getTracks().forEach(t => t.stop());
                
                const devices = await navigator.mediaDevices.enumerateDevices();
                const videoDevices = devices.filter(device => device.kind === 'videoinput');
                
                log(`üìπ ${videoDevices.length} c√¢mera(s) encontrada(s)`);
                
                availableCameras = videoDevices.map((device, index) => {
                    const label = device.label.toLowerCase();
                    let facingMode = 'unknown';
                    let estimatedRes = { width: 1920, height: 1080 };
                    
                    if (label.includes('back') || label.includes('rear') || label.includes('traseira')) {
                        facingMode = 'environment';
                        estimatedRes = { width: 3840, height: 2160 };
                        log(`  üì∑ ${device.label || 'C√¢mera ' + (index + 1)} - TRASEIRA (estimado 4K)`);
                    } else if (label.includes('front') || label.includes('frontal')) {
                        facingMode = 'user';
                        estimatedRes = { width: 1920, height: 1080 };
                        log(`  ü§≥ ${device.label || 'C√¢mera ' + (index + 1)} - FRONTAL (estimado 1080p)`);
                    } else {
                        log(`  üìπ ${device.label || 'C√¢mera ' + (index + 1)} - Desconhecida`);
                    }
                    
                    return {
                        id: device.deviceId,
                        label: device.label || `C√¢mera ${index + 1}`,
                        facingMode: facingMode,
                        maxResolution: estimatedRes
                    };
                });
                
                bestCamera = availableCameras.reduce((best, current) => {
                    const bestPixels = best.maxResolution.width * best.maxResolution.height;
                    const currentPixels = current.maxResolution.width * current.maxResolution.height;
                    return currentPixels > bestPixels ? current : best;
                }, availableCameras[0]);
                
                log(`üèÜ Melhor: ${bestCamera.label}`);
                
                cameraSelect.innerHTML = '';
                availableCameras.forEach((cam) => {
                    const option = document.createElement('option');
                    option.value = cam.id;
                    
                    const isBest = cam.id === bestCamera.id;
                    const facingIcon = cam.facingMode === 'environment' ? 'üì∑' : 
                                      cam.facingMode === 'user' ? 'ü§≥' : 'üìπ';
                    const bestBadge = isBest ? ' üèÜ' : '';
                    
                    option.textContent = `${facingIcon} ${cam.label}${bestBadge}`;
                    
                    cameraSelect.appendChild(option);
                    
                    if (isBest) {
                        cameraSelect.value = cam.id;
                        selectedCameraId = cam.id;
                    }
                });
                
                cameraSelect.disabled = false;
                updateCameraInfo();
                
                if (socket && roomId) {
                    sendCameraListToDesktop();
                }
                
                log('‚úÖ Detec√ß√£o completa!');
                
            } catch (e) {
                log('‚ùå Erro: ' + e.message);
                cameraSelect.innerHTML = '<option>Erro ao detectar</option>';
            }
        }

        function sendCameraListToDesktop() {
            if (!socket || !roomId) return;
            
            socket.emit('camera-list', {
                roomId,
                cameras: availableCameras.map(c => ({
                    id: c.id,
                    label: c.label,
                    facingMode: c.facingMode,
                    maxResolution: c.maxResolution,
                    isBest: c.id === bestCamera.id
                })),
                selectedCameraId: selectedCameraId
            });
            
            log('üì§ Lista enviada');
        }

        function updateCameraInfo() {
            const cam = availableCameras.find(c => c.id === cameraSelect.value);
            if (!cam) return;
            
            const isBest = cam.id === bestCamera.id;
            const facingText = cam.facingMode === 'environment' ? 'Traseira' : 
                              cam.facingMode === 'user' ? 'Frontal' : 'Desconhecida';
            
            cameraInfo.innerHTML = `
                <strong>${cam.label}</strong><br>
                üìç ${facingText}<br>
                ${isBest ? 'üèÜ Melhor c√¢mera!' : ''}
            `;
            cameraInfo.style.display = 'block';
            cameraInfo.className = isBest ? 'camera-info best' : 'camera-info';
        }

        cameraSelect.addEventListener('change', () => {
            selectedCameraId = cameraSelect.value;
            updateCameraInfo();
            
            if (localStream) {
                restartBtn.style.background = '#FF9800';
                restartBtn.textContent = 'üîÑ TROCAR C√ÇMERA';
            }
        });

        function applyZoom(zoomLevel) {
            if (!videoTrack) return;

            const capabilities = videoTrack.getCapabilities();
                console.log('üìπ CAPABILITIES COMPLETAS:', JSON.stringify(capabilities, null, 2));
            if (!capabilities.zoom) return;

            const clampedZoom = Math.max(zoomMin, Math.min(zoomMax, parseFloat(zoomLevel)));
            
            currentZoomLevel = clampedZoom;
            const displayZoom = clampedZoom.toFixed(1);
            currentZoom.textContent = displayZoom + 'x';
            zoomIndicator.textContent = `üîç ${displayZoom}x`;
            zoomInfo.textContent = `Zoom: ${displayZoom}x / Max: ${zoomMax.toFixed(1)}x`;

            if (zoomDebounceTimer) {
                clearTimeout(zoomDebounceTimer);
            }

            zoomDebounceTimer = setTimeout(async () => {
                try {
                    await videoTrack.applyConstraints({
                        advanced: [{ zoom: clampedZoom }]
                    });

                    if (socket && roomId) {
                        socket.emit('zoom-update', { 
                            roomId, 
                            zoom: clampedZoom,
                            zoomMin: zoomMin,
                            zoomMax: zoomMax
                        });
                    }
                } catch (e) {}
            }, 200);
        }

        async function startCamera() {
            const [width, height] = resolutionSelect.value.split('x').map(Number);
            const fps = parseInt(fpsSelect.value);
            const bitrate = parseInt(bitrateSelect.value);

            log(`üìπ ${width}x${height} @ ${fps}fps`);
            updateStatus('Iniciando...');

            try {
                if (localStream) {
                    localStream.getTracks().forEach(track => track.stop());
                }

                const constraints = {
                    video: {
                        deviceId: selectedCameraId ? { exact: selectedCameraId } : undefined,
                        width: { ideal: width },
                        height: { ideal: height },
                        frameRate: { ideal: fps }
                    },
                    audio: false
                };

                localStream = await navigator.mediaDevices.getUserMedia(constraints);
                video.srcObject = localStream;
                videoTrack = localStream.getVideoTracks()[0];

                const settings = videoTrack.getSettings();
                const capabilities = videoTrack.getCapabilities();
                console.log('üìπ CAPABILITIES COMPLETAS:', JSON.stringify(capabilities, null, 2));

                const cam = availableCameras.find(c => c.id === settings.deviceId);
                if (cam) {
                    currentCamera.textContent = cam.label;
                }

                if (capabilities.zoom) {
                    zoomMin = capabilities.zoom.min || 1.0;
                    zoomMax = capabilities.zoom.max || 10.0;
                    currentZoomLevel = settings.zoom || 1.0;
                    
                    zoomInfo.textContent = `Zoom: ${currentZoomLevel.toFixed(1)}x / Max: ${zoomMax.toFixed(1)}x`;
                    
                    if (socket && roomId) {
                        socket.emit('zoom-capabilities', { 
                            roomId, 
                            zoomMin, 
                            zoomMax,
                            currentZoom: currentZoomLevel
                        });
                    }
                }

                const actualRes = `${settings.width}x${settings.height}`;
                const actualFps = settings.frameRate;

                currentResolution.textContent = actualRes;
                currentFps.textContent = actualFps + ' fps';
                currentBitrate.textContent = (bitrate/1000000).toFixed(1) + ' Mbps';

                log(`‚úÖ ${actualRes} @ ${actualFps}fps`);

                updateStatus('C√¢mera OK');
                
                if (socket) {
                    socket.emit('config-update', { 
                        roomId, 
                        resolution: resolutionSelect.value,
                        bitrate: bitrateSelect.value,
                        fps: fpsSelect.value
                    });
                }
                
                return true;

            } catch (e) {
                log('‚ùå Erro: ' + e.message);
                updateStatus('Erro');
                return false;
            }
        }

        async function setupPeerConnection() {
            peerConnection = new RTCPeerConnection(config);

            videoTrack = localStream.getVideoTracks()[0];
            videoSender = peerConnection.addTrack(videoTrack, localStream);

            await applyEncoderSettings();

            peerConnection.onicecandidate = (e) => {
                if (e.candidate) {
                    socket.emit('ice-candidate', { roomId, candidate: e.candidate });
                }
            };

            peerConnection.onconnectionstatechange = () => {
                log('üîó ' + peerConnection.connectionState);
                if (peerConnection.connectionState === 'connected') {
                    updateStatus('Transmitindo');
                }
            };
        }

        async function applyEncoderSettings() {
            const bitrate = parseInt(bitrateSelect.value);
            const fps = parseInt(fpsSelect.value);

            const parameters = videoSender.getParameters();
            if (!parameters.encodings) {
                parameters.encodings = [{}];
            }

            parameters.encodings[0].maxBitrate = bitrate;
            parameters.encodings[0].minBitrate = Math.floor(bitrate * 0.95);
            parameters.encodings[0].maxFramerate = fps;
            parameters.encodings[0].priority = 'high';
            parameters.encodings[0].networkPriority = 'high';
            parameters.encodings[0].scaleResolutionDownBy = 1;

            await videoSender.setParameters(parameters);
        }

        startBtn.onclick = async () => {
            roomId = roomIdInput.value.trim();
            if (!roomId) return alert('‚ö†Ô∏è Digite um ID!');

            startBtn.disabled = true;
            
            await detectCameras();
            
            const success = await startCamera();
            if (!success) {
                startBtn.disabled = false;
                return;
            }

            socket = io();

            socket.on('connect', () => {
                log('‚úÖ Socket conectado');
                updateStatus('Socket OK');
                socket.emit('join-room', roomId);
                
                setTimeout(() => {
                    sendCameraListToDesktop();
                }, 500);
            });

            socket.on('user-joined', async (userId) => {
                log('üë§ Desktop: ' + userId);
                
                setTimeout(async () => {
                    await setupPeerConnection();
                    const offer = await peerConnection.createOffer();
                    await peerConnection.setLocalDescription(offer);
                    socket.emit('offer', { roomId, offer });
                    
                    setTimeout(() => {
                        sendCameraListToDesktop();
                    }, 1000);
                }, 1000);
            });

            socket.on('answer', async (data) => {
                await peerConnection.setRemoteDescription(new RTCSessionDescription(data.answer));
                updateStatus('Transmitindo');
            });

            socket.on('ice-candidate', async (data) => {
                if (data.candidate) {
                    await peerConnection.addIceCandidate(new RTCIceCandidate(data.candidate));
                }
            });

            socket.on('camera-control', (data) => {
                if (data.control === 'zoom') {
                    applyZoom(data.value);
                } else {
                    applyCommand(data);
                }
            });

            socket.on('change-camera', (data) => {
                if (data.cameraId) {
                    log(`üñ•Ô∏è Troca: ${data.cameraId}`);
                    selectedCameraId = data.cameraId;
                    cameraSelect.value = data.cameraId;
                    updateCameraInfo();
                    restartCamera();
                }
            });

            socket.on('change-config', async (data) => {
                if (data.type === 'resolution' && data.value) {
                    resolutionSelect.value = data.value;
                }
                if (data.type === 'bitrate' && data.value) {
                    bitrateSelect.value = data.value;
                }
                if (data.type === 'fps' && data.value) {
                    fpsSelect.value = data.value;
                }
                if (data.type === 'latency' && data.value) {
                    latencySelect.value = data.value;
                }
                
                await restartCamera();
            });


            socket.on('request-camera-list', () => {
                console.log('üñ•Ô∏è Desktop solicitou lista de c√¢meras');
                sendCameraListToDesktop();
            });

            socket.on('disconnect', () => {
                log('‚ùå Desconectado');
                updateStatus('Desconectado');
            });

            restartBtn.style.display = 'block';
            startBtn.textContent = '‚úÖ Ativa';
            roomIdInput.disabled = true;
        };

        async function restartCamera() {
            log('üîÑ Reiniciando...');
            
            const previousZoom = currentZoomLevel;
            
            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
            }
            
            const success = await startCamera();
            
            if (success && videoSender && peerConnection) {
                const newTrack = localStream.getVideoTracks()[0];
                await videoSender.replaceTrack(newTrack);
                videoTrack = newTrack;
                await applyEncoderSettings();
                
                setTimeout(() => {
                    applyZoom(previousZoom);
                }, 500);
                
                log('‚úÖ Reiniciada!');
            }
        }

        restartBtn.onclick = restartCamera;

        [resolutionSelect, bitrateSelect, fpsSelect].forEach(select => {
            select.addEventListener('change', () => {
                restartBtn.style.background = '#FF9800';
                restartBtn.textContent = 'üîÑ APLICAR';
            });
        });

        function applyCommand(data) {
            if (!videoTrack) return;

            const capabilities = videoTrack.getCapabilities();
                console.log('üìπ CAPABILITIES COMPLETAS:', JSON.stringify(capabilities, null, 2));

            if (data.control === 'iso' && capabilities.iso) {
                const val = parseInt(data.value);
                const clamped = Math.max(capabilities.iso.min, Math.min(capabilities.iso.max, val));
                videoTrack.applyConstraints({
                    advanced: [{ iso: clamped }]
                }).catch(() => {});
            }

            if (data.control === 'exposure' && capabilities.exposureCompensation) {
                const val = parseFloat(data.value);
                const clamped = Math.max(capabilities.exposureCompensation.min, Math.min(capabilities.exposureCompensation.max, val));
                videoTrack.applyConstraints({
                    advanced: [{ exposureCompensation: clamped }]
                }).catch(() => {});
            }
        }

        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('/service-worker.js').catch(() => {});
        }
    </script>
</body>
</html>
