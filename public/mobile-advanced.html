## FILE 1: mobile-advanced.html
```html
<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Camera Remote Pro - Mobile Advanced</title>
    <link rel="manifest" href="manifest.json">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#667eea">
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body { 
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #fff;
            padding: 15px;
            min-height: 100vh;
        }
        .container {
            max-width: 600px;
            margin: 0 auto;
            background: rgba(0,0,0,0.8);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.5);
        }
        h1 { text-align: center; margin-bottom: 10px; font-size: 24px; }
        .subtitle {
            text-align: center;
            color: #0f0;
            font-size: 12px;
            margin-bottom: 20px;
        }
        .status-panel {
            background: rgba(255,255,255,0.1);
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
        }
        .status-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 14px;
        }
        .status-value {
            color: #0f0;
            font-weight: bold;
        }
        .video-container {
            width: 100%;
            height: 400px;
            overflow: hidden;
            border-radius: 10px;
            border: 3px solid #0f0;
            margin-bottom: 20px;
            background: #000;
            position: relative;
        }
        video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        .zoom-indicator {
            position: absolute;
            top: 15px;
            right: 15px;
            background: rgba(0,0,0,0.85);
            color: #0f0;
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 18px;
            font-weight: bold;
            border: 2px solid #0f0;
            box-shadow: 0 0 10px rgba(0,255,0,0.3);
        }
        .zoom-info {
            position: absolute;
            bottom: 15px;
            left: 15px;
            background: rgba(0,0,0,0.85);
            color: #fff;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 12px;
            border: 1px solid #667eea;
        }
        .config-section {
            background: rgba(255,255,255,0.05);
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 15px;
        }
        .config-title {
            font-size: 16px;
            font-weight: bold;
            margin-bottom: 10px;
            color: #667eea;
        }
        label {
            display: block;
            margin-bottom: 5px;
            font-size: 14px;
        }
        select, input[type="text"], button {
            width: 100%;
            padding: 12px;
            margin-bottom: 15px;
            border: none;
            border-radius: 8px;
            font-size: 16px;
        }
        select, input[type="text"] {
            background: rgba(255,255,255,0.1);
            color: #fff;
            border: 2px solid rgba(255,255,255,0.2);
        }
        select option {
            background: #2a2a2a;
            color: #fff;
        }
        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #fff;
            font-weight: bold;
            cursor: pointer;
            font-size: 18px;
            padding: 15px;
        }
        button:disabled {
            background: #555;
            opacity: 0.5;
        }
        .camera-info {
            background: rgba(0,255,0,0.1);
            padding: 10px;
            border-radius: 8px;
            margin-top: 10px;
            font-size: 12px;
            border: 1px solid #0f0;
        }
        .camera-info.best {
            background: rgba(255,215,0,0.1);
            border-color: #FFD700;
            color: #FFD700;
        }
        .log {
            background: #000;
            color: #0f0;
            padding: 10px;
            border-radius: 8px;
            height: 250px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            margin-top: 15px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üì± CAMERA REMOTE PRO</h1>
        <div class="subtitle">‚úÖ Sele√ß√£o de C√¢meras + Zoom + Lat√™ncia Zero</div>

        <div class="status-panel">
            <div class="status-row">
                <span>Status:</span>
                <span class="status-value" id="status">Desconectado</span>
            </div>
            <div class="status-row">
                <span>C√¢mera:</span>
                <span class="status-value" id="currentCamera">-</span>
            </div>
            <div class="status-row">
                <span>Resolu√ß√£o:</span>
                <span class="status-value" id="currentResolution">-</span>
            </div>
            <div class="status-row">
                <span>FPS:</span>
                <span class="status-value" id="currentFps">-</span>
            </div>
            <div class="status-row">
                <span>Bitrate:</span>
                <span class="status-value" id="currentBitrate">-</span>
            </div>
            <div class="status-row">
                <span>Zoom:</span>
                <span class="status-value" id="currentZoom">1.0x</span>
            </div>
        </div>

        <div class="video-container">
            <video id="video" autoplay playsinline muted></video>
            <div class="zoom-indicator" id="zoomIndicator">üîç 1.0x</div>
            <div class="zoom-info" id="zoomInfo">Zoom: 1.0x / Max: -</div>
        </div>

        <div class="config-section">
            <div class="config-title">üìπ SELECIONAR C√ÇMERA</div>
            <select id="cameraSelect" disabled>
                <option value="">Detectando c√¢meras...</option>
            </select>
            <div class="camera-info" id="cameraInfo" style="display:none;"></div>
        </div>

        <div class="config-section">
            <div class="config-title">üìê RESOLU√á√ÉO</div>
            <select id="resolutionSelect">
                <option value="640x480">VGA 480p (640x480)</option>
                <option value="1280x720">HD 720p (1280x720)</option>
                <option value="1920x1080" selected>Full HD 1080p (1920x1080)</option>
                <option value="2560x1440">2K QHD (2560x1440)</option>
                <option value="3840x2160">4K UHD (3840x2160)</option>
            </select>
        </div>

        <div class="config-section">
            <div class="config-title">üìä BITRATE</div>
            <select id="bitrateSelect">
                <option value="2000000">2 Mbps (Ultra Baixa Lat√™ncia)</option>
                <option value="5000000">5 Mbps (Baixa Lat√™ncia)</option>
                <option value="10000000">10 Mbps (M√©dia)</option>
                <option value="15000000" selected>15 Mbps (Mais ou Menos)</option>
                <option value="20000000">20 Mbps (Alta)</option>
                <option value="30000000">30 Mbps (Ultra)</option>
                <option value="50000000">50 Mbps (M√°xima - 4K)</option>
            </select>
        </div>

        <div class="config-section">
            <div class="config-title">üé¨ FPS</div>
            <select id="fpsSelect">
                <option value="15">15 FPS (Ultra Baixa Lat√™ncia)</option>
                <option value="20">20 FPS (Baixa Lat√™ncia)</option>
                <option value="24">24 FPS (M√©dia)</option>
                <option value="30" selected>30 FPS (Mais ou Menos)</option>
                <option value="60">60 FPS (Alta Lat√™ncia)</option>
            </select>
        </div>

        <label>ID da Sala:</label>
        <input type="text" id="roomId" placeholder="Digite o ID da sala">
        
        <button id="startBtn">üöÄ INICIAR</button>
        <button id="restartBtn" style="display:none; background:#f44336;">üîÑ APLICAR MUDAN√áAS</button>

        <div class="log" id="log"></div>
    </div>

    <script src="/socket.io/socket.io.js"></script>
    <script>
        const video = document.getElementById('video');
        const roomIdInput = document.getElementById('roomId');
        const startBtn = document.getElementById('startBtn');
        const restartBtn = document.getElementById('restartBtn');
        const cameraSelect = document.getElementById('cameraSelect');
        const cameraInfo = document.getElementById('cameraInfo');
        const resolutionSelect = document.getElementById('resolutionSelect');
        const bitrateSelect = document.getElementById('bitrateSelect');
        const fpsSelect = document.getElementById('fpsSelect');
        const statusSpan = document.getElementById('status');
        const currentCamera = document.getElementById('currentCamera');
        const currentResolution = document.getElementById('currentResolution');
        const currentFps = document.getElementById('currentFps');
        const currentBitrate = document.getElementById('currentBitrate');
        const currentZoom = document.getElementById('currentZoom');
        const zoomIndicator = document.getElementById('zoomIndicator');
        const zoomInfo = document.getElementById('zoomInfo');
        const logDiv = document.getElementById('log');

        let socket = null;
        let peerConnection = null;
        let localStream = null;
        let roomId = null;
        let videoTrack = null;
        let videoSender = null;
        let zoomMin = 1.0;
        let zoomMax = 10.0;
        let currentZoomLevel = 1.0;
        let bufferDelay = 100; // Default buffer delay
        let zoomDebounceTimer = null;
        let availableCameras = [];
        let bestCamera = null;
        let selectedCameraId = null;

        const config = { 
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:stun1.l.google.com:19302' }
            ],
            iceTransportPolicy: 'all',
            bundlePolicy: 'max-bundle',
            rtcpMuxPolicy: 'require'
        };

        function log(msg) {
            console.log(msg);
            const timestamp = new Date().toLocaleTimeString();
            logDiv.innerHTML += `[${timestamp}] ${msg}<br>`;
            logDiv.scrollTop = logDiv.scrollHeight;
        }

        function updateStatus(text) {
            statusSpan.textContent = text;
        }

        async function detectCameras() {
            log('üîç INICIANDO DETEC√á√ÉO DE C√ÇMERAS...');
            
            try {
                log('üì∏ Pedindo permiss√£o de c√¢mera...');
                // Request generic permission first to ensure enumerateDevices works
                const tempStream = await navigator.mediaDevices.getUserMedia({ video: true });
                tempStream.getTracks().forEach(t => t.stop()); // Stop temporary stream
                log('‚úÖ Permiss√£o concedida!');
                
                log('üìã Enumerando dispositivos...');
                const devices = await navigator.mediaDevices.enumerateDevices();
                const videoDevices = devices.filter(device => device.kind === 'videoinput');
                
                log(`üìπ ENCONTRADAS ${videoDevices.length} C√ÇMERA(S):`);
                videoDevices.forEach((device, index) => {
                    log(`  ${index + 1}. ${device.label || 'C√¢mera ' + (index + 1)} (ID: ${device.deviceId.substring(0, 8)}...)`);
                });
                
                availableCameras = [];
                
                for (let i = 0; i < videoDevices.length; i++) {
                    const device = videoDevices[i];
                    
                    log(`üî¨ Testando c√¢mera ${i + 1}/${videoDevices.length}: ${device.label || 'C√¢mera ' + (i + 1)}`);
                    
                    const cameraData = {
                        id: device.deviceId,
                        label: device.label || `C√¢mera ${i + 1}`,
                        facingMode: 'unknown',
                        maxResolution: { width: 0, height: 0 }
                    };
                    
                    // Detectar facing mode pelo label
                    const label = device.label.toLowerCase();
                        cameraData.facingMode = 'environment';
                        log(`  üì∑ Posi√ß√£o: TRASEIRA`);
                        cameraData.facingMode = 'user';
                        log(`  ü§≥ Posi√ß√£o: FRONTAL`);
                    } else {
                        log(`  ‚ùì Posi√ß√£o: DESCONHECIDA`);
                    }
                    
                    // Tentar obter resolu√ß√£o m√°xima
                    try {
                        log(`  üîç Tentando obter resolu√ß√£o m√°xima...`);
                        const testStream = await navigator.mediaDevices.getUserMedia({
                            video: { 
                                deviceId: { exact: device.deviceId },
                                width: { ideal: 4096 }, // Request very high resolution
                                height: { ideal: 4096 }
                            }
                        });
                        
                        const track = testStream.getVideoTracks()[0];
                        const settings = track.getSettings();
                        cameraData.maxResolution = {
                            width: settings.width || 0,
                            height: settings.height || 0
                        };
                        
                        testStream.getTracks().forEach(t => t.stop()); // Stop test stream
                        
                        log(`  ‚úÖ Resolu√ß√£o detectada: ${settings.width}x${settings.height}`);
                    } catch (e) {
                        log(`  ‚ö†Ô∏è Erro ao testar resolu√ß√£o para ${cameraData.label}: ${e.message}. Usando padr√£o 1920x1080.`);
                        cameraData.maxResolution = { width: 1920, height: 1080 }; // Fallback
                    }
                    
                    availableCameras.push(cameraData);
                }
                
                if (availableCameras.length === 0) {
                    log('‚ùå NENHUMA C√ÇMERA DE V√çDEO ENCONTRADA!');
                    cameraSelect.innerHTML = '<option value="">Nenhuma c√¢mera encontrada</option>';
                    return;
                }
                
                // Identificar a melhor c√¢mera (maior n√∫mero de pixels)
                bestCamera = availableCameras.reduce((best, current) => {
                    const bestPixels = best.maxResolution.width * best.maxResolution.height;
                    const currentPixels = current.maxResolution.width * current.maxResolution.height;
                    return currentPixels > bestPixels ? current : best;
                }, availableCameras[0]); // Initialize with the first camera
                
                log(`üèÜ MELHOR C√ÇMERA: ${bestCamera.label} (${bestCamera.maxResolution.width}x${bestCamera.maxResolution.height})`);
                
                // Popula o dropdown
                cameraSelect.innerHTML = '';
                availableCameras.forEach((cam) => {
                    const option = document.createElement('option');
                    option.value = cam.id;
                    
                    const isBest = cam.id === bestCamera.id;
                    const facingIcon = cam.facingMode === 'environment' ? 'üì∑' : 
                                      cam.facingMode === 'user' ? 'ü§≥' : 'üìπ';
                    const bestBadge = isBest ? ' üèÜ MELHOR' : '';
                    
                    option.textContent = `${facingIcon} ${cam.label} (${cam.maxResolution.width}x${cam.maxResolution.height})${bestBadge}`;
                    
                    cameraSelect.appendChild(option);
                    
                    // Seleciona automaticamente a melhor c√¢mera
                    if (isBest) {
                        cameraSelect.value = cam.id;
                        selectedCameraId = cam.id;
                    }
                });
                
                cameraSelect.disabled = false;
                updateCameraInfo(); // Update local info display
                
                // Send camera list to desktop if socket is connected
                if (socket && roomId) {
                    sendCameraListToDesktop();
                }
                
            } catch (e) {
                log('‚ùå ERRO GERAL NA DETEC√á√ÉO DE C√ÇMERAS: ' + e.message);
                cameraSelect.innerHTML = '<option value="">Erro ao detectar c√¢meras</option>';
            }
        }

        function sendCameraListToDesktop() {
            if (!socket || !roomId) {
                log('‚ö†Ô∏è N√£o foi poss√≠vel enviar lista de c√¢meras: socket ou roomId n√£o definidos.');
                return;
            }
            
            socket.emit('camera-list', {
                roomId,
                cameras: availableCameras.map(c => ({
                    id: c.id,
                    label: c.label,
                    facingMode: c.facingMode,
                    maxResolution: c.maxResolution,
                    isBest: c.id === bestCamera.id
                })),
                selectedCameraId: selectedCameraId
            });
            
            log('üì§ Lista de c√¢meras enviada para o desktop.');
        }

        function updateCameraInfo() {
            const cam = availableCameras.find(c => c.id === cameraSelect.value);
            if (!cam) {
                cameraInfo.style.display = 'none';
                return;
            }
            
            const isBest = cam.id === bestCamera.id;
            const facingText = cam.facingMode === 'environment' ? 'Traseira' : 
                              cam.facingMode === 'user' ? 'Frontal' : 'Desconhecida';
            
            cameraInfo.innerHTML = `
                <strong>${cam.label}</strong><br>
                üìç Posi√ß√£o: ${facingText}<br>
                üìê Resolu√ß√£o M√°xima: ${cam.maxResolution.width}x${cam.maxResolution.height}<br>
                ${isBest ? 'üèÜ Esta √© a c√¢mera com MELHOR resolu√ß√£o!' : ''}
            `;
            cameraInfo.style.display = 'block';
            cameraInfo.className = isBest ? 'camera-info best' : 'camera-info';
        }

        cameraSelect.addEventListener('change', () => {
            selectedCameraId = cameraSelect.value;
            updateCameraInfo();
            
            if (localStream) {
                restartBtn.style.background = '#FF9800';
                restartBtn.textContent = 'üîÑ APLICAR MUDAN√áAS (Trocar C√¢mera)';
            }
        });

        function applyZoom(zoomLevel) {
            if (!videoTrack) {
                log('‚ö†Ô∏è N√£o h√° v√≠deo track para aplicar zoom.');
                return;
            }

            const capabilities = videoTrack.getCapabilities();
            
            if (!capabilities.zoom) {
                log('‚ö†Ô∏è Zoom n√£o suportado por esta c√¢mera.');
                return;
            }

            const clampedZoom = Math.max(zoomMin, Math.min(zoomMax, parseFloat(zoomLevel)));
            
            currentZoomLevel = clampedZoom;
            const displayZoom = clampedZoom.toFixed(1);
            currentZoom.textContent = displayZoom + 'x';
            zoomIndicator.textContent = `üîç ${displayZoom}x`;
            zoomInfo.textContent = `Zoom: ${displayZoom}x / Max: ${zoomMax.toFixed(1)}x`;

            if (zoomDebounceTimer) {
                clearTimeout(zoomDebounceTimer);
            }

            zoomDebounceTimer = setTimeout(async () => {
                try {
                    await videoTrack.applyConstraints({
                        advanced: [{ zoom: clampedZoom }]
                    });

                    log(`üîç Zoom aplicado: ${clampedZoom.toFixed(1)}x`);

                    if (socket && roomId) {
                        socket.emit('zoom-update', { 
                            roomId, 
                            zoom: clampedZoom,
                            zoomMin: zoomMin,
                            zoomMax: zoomMax
                        });
                    }
                } catch (e) {
                    log('‚ùå Erro ao aplicar zoom: ' + e.message);
                }
            }, 200); // 200ms debounce
        }

        async function startCamera() {
            const [width, height] = resolutionSelect.value.split('x').map(Number);
            const fps = parseInt(fpsSelect.value);
            const bitrate = parseInt(bitrateSelect.value);

            log(`üìπ Iniciando c√¢mera com: ${width}x${height} @ ${fps}fps, ${(bitrate/1000000).toFixed(1)} Mbps`);
            updateStatus('Iniciando c√¢mera...');

            try {
                if (localStream) {
                    localStream.getTracks().forEach(track => track.stop());
                }

                const constraints = {
                    video: {
                        deviceId: selectedCameraId ? { exact: selectedCameraId } : undefined,
                        width: { ideal: width },
                        height: { ideal: height },
                        frameRate: { ideal: fps }
                    },
                    audio: false
                };

                localStream = await navigator.mediaDevices.getUserMedia(constraints);
                video.srcObject = localStream;
                videoTrack = localStream.getVideoTracks()[0];

                const settings = videoTrack.getSettings();
                const capabilities = videoTrack.getCapabilities();

                // Update current camera label in status panel
                const cam = availableCameras.find(c => c.id === settings.deviceId);
                if (cam) {
                    currentCamera.textContent = cam.label;
                    log(`üì∏ C√¢mera ativa: ${cam.label}`);
                } else {
                    currentCamera.textContent = 'Desconhecida';
                    log(`üì∏ C√¢mera ativa: ID ${settings.deviceId.substring(0,8)}... (Desconhecida)`);
                }

                if (capabilities.zoom) {
                    zoomMin = capabilities.zoom.min || 1.0;
                    zoomMax = capabilities.zoom.max || 10.0;
                    currentZoomLevel = settings.zoom || 1.0;
                    
                    log(`‚úÖ Zoom dispon√≠vel: Min ${zoomMin.toFixed(1)}x - Max ${zoomMax.toFixed(1)}x`);
                    zoomInfo.textContent = `Zoom: ${currentZoomLevel.toFixed(1)}x / Max: ${zoomMax.toFixed(1)}x`;
                    
                    if (socket && roomId) {
                        socket.emit('zoom-capabilities', { 
                            roomId, 
                            zoomMin, 
                            zoomMax,
                            currentZoom: currentZoomLevel
                        });
                    }
                } else {
                    log('‚ö†Ô∏è Zoom n√£o suportado por esta c√¢mera.');
                    zoomInfo.textContent = 'Zoom n√£o dispon√≠vel';
                }

                const actualRes = `${settings.width}x${settings.height}`;
                const actualFps = settings.frameRate;

                currentResolution.textContent = actualRes;
                currentFps.textContent = actualFps + ' fps';
                currentBitrate.textContent = (bitrate/1000000).toFixed(1) + ' Mbps';

                log(`‚úÖ C√¢mera iniciada com: ${actualRes} @ ${actualFps}fps`);

                updateStatus('C√¢mera OK');
                
                if (socket) {
                    socket.emit('config-update', { 
                        roomId, 
                        resolution: resolutionSelect.value,
                        bitrate: bitrateSelect.value,
                        fps: fpsSelect.value
                    });
                }
                
                return true;

            } catch (e) {
                log('‚ùå ERRO AO INICIAR C√ÇMERA: ' + e.message);
                updateStatus('Erro na c√¢mera');
                return false;
            }
        }

        async function setupPeerConnection() {
            peerConnection = new RTCPeerConnection(config);

            videoTrack = localStream.getVideoTracks()[0];
            videoSender = peerConnection.addTrack(videoTrack, localStream);

            await applyEncoderSettings();

            peerConnection.onicecandidate = (e) => {
                if (e.candidate) {
                    socket.emit('ice-candidate', { roomId, candidate: e.candidate });
                }
            };

            peerConnection.onconnectionstatechange = () => {
                log('üîó Estado da conex√£o WebRTC: ' + peerConnection.connectionState);
                if (peerConnection.connectionState === 'connected') {
                    updateStatus('Transmitindo');
                } else if (peerConnection.connectionState === 'disconnected' || peerConnection.connectionState === 'failed') {
                    updateStatus('Conex√£o perdida');
                }
            };

            log('‚úÖ PeerConnection configurado.');
        }

        async function applyEncoderSettings() {
            const bitrate = parseInt(bitrateSelect.value);
            const fps = parseInt(fpsSelect.value);

            const parameters = videoSender.getParameters();
            if (!parameters.encodings) {
                parameters.encodings = [{}];
            }

            parameters.encodings[0].maxBitrate = bitrate;
            parameters.encodings[0].minBitrate = Math.floor(bitrate * 0.8);
            parameters.encodings[0].maxFramerate = fps;
            parameters.encodings[0].priority = 'high';
            parameters.encodings[0].networkPriority = 'high';
            parameters.encodings[0].scaleResolutionDownBy = 1; // Ensure full resolution is sent

            await videoSender.setParameters(parameters);
            log(`‚öôÔ∏è Encoder configurado: ${(bitrate/1000000).toFixed(1)}Mbps, ${fps}fps`);
        }

        startBtn.onclick = async () => {
            roomId = roomIdInput.value.trim();
            if (!roomId) {
                alert('‚ö†Ô∏è Digite um ID para a sala!');
                return;
            }

            startBtn.disabled = true;
            
            // Detect cameras before starting stream
            await detectCameras();
            
            const success = await startCamera();
            if (!success) {
                startBtn.disabled = false;
                return;
            }

            socket = io();

            socket.on('connect', () => {
                log('‚úÖ Socket.io conectado.');
                updateStatus('Socket OK');
                socket.emit('join-room', roomId);
                log(`üì° Entrou na sala: ${roomId}`);
                
                // Send camera list after socket connects and room is joined
                sendCameraListToDesktop();
            });

            socket.on('user-joined', async (userId) => {
                log('üë§ Desktop entrou na sala: ' + userId);
                
                // Give a small delay for desktop to be ready
                setTimeout(async () => {
                    log('üì§ Criando OFFER WebRTC...');
                    await setupPeerConnection();
                    const offer = await peerConnection.createOffer();
                    await peerConnection.setLocalDescription(offer);
                    socket.emit('offer', { roomId, offer });
                    log('üì§ OFFER enviada.');
                    
                    // Re-send capabilities and camera list after peer connection is established
                    setTimeout(() => {
                        if (videoTrack) {
                            const capabilities = videoTrack.getCapabilities();
                            if (capabilities.zoom) {
                                socket.emit('zoom-capabilities', { 
                                    roomId, 
                                    zoomMin, 
                                    zoomMax,
                                    currentZoom: currentZoomLevel
                                });
                                log('üì§ Capacidades de zoom enviadas.');
                            }
                        }
                        sendCameraListToDesktop(); // Re-send camera list
                    }, 1000);
                }, 1000);
            });

            socket.on('answer', async (data) => {
                log('üì• ANSWER WebRTC recebida.');
                await peerConnection.setRemoteDescription(new RTCSessionDescription(data.answer));
                updateStatus('Transmitindo');
            });

            socket.on('ice-candidate', async (data) => {
                if (data.candidate && peerConnection) {
                    await peerConnection.addIceCandidate(new RTCIceCandidate(data.candidate));
                    log('üì• ICE Candidate adicionado.');
                }
            });

            socket.on('camera-control', (data) => {
                if (data.control === 'zoom') {
                    applyZoom(data.value);
                } else {
                    applyCommand(data);
                }
                log(`üñ•Ô∏è Comando de c√¢mera recebido: ${data.control} = ${data.value}`);
            });

            socket.on('change-camera', (data) => {
                if (data.cameraId) {
                    log(`üñ•Ô∏è Desktop solicitou troca para c√¢mera: ${data.cameraId}`);
                    selectedCameraId = data.cameraId;
                    cameraSelect.value = data.cameraId; // Update local dropdown
                    updateCameraInfo(); // Update local info display
                    restartCamera(); // Restart stream with new camera
                }
            });

            socket.on('change-config', async (data) => {
                log('üñ•Ô∏è Desktop solicitou mudan√ßa de configura√ß√£o.');
                
                if (data.type === 'resolution' && data.value) {
                    resolutionSelect.value = data.value;
                    log(`üìπ Resolu√ß√£o alterada para: ${data.value}`);
                }
                if (data.type === 'bitrate' && data.value) {
                    bitrateSelect.value = data.value;
                    log(`üìä Bitrate alterado para: ${(data.value/1000000).toFixed(1)}Mbps`);
                }
                if (data.type === 'fps' && data.value) {
                    fpsSelect.value = data.value;
                    log(`üé¨ FPS alterado para: ${data.value}`);
                }
                
                await restartCamera();
            });

            socket.on('latency-buffer', (data) => {
                bufferDelay = data.bufferDelay;
                log(`‚è±Ô∏è Buffer de envio ajustado para: ${bufferDelay}ms (Desktop controlando)`);
            });

            socket.on('disconnect', () => {
                log('‚ùå Desconectado do servidor.');
                updateStatus('Desconectado');
                if (localStream) {
                    localStream.getTracks().forEach(track => track.stop());
                }
                video.srcObject = null;
                startBtn.disabled = false;
                startBtn.textContent = 'üöÄ INICIAR';
                roomIdInput.disabled = false;
                restartBtn.style.display = 'none';
            });

            restartBtn.style.display = 'block';
            startBtn.textContent = '‚úÖ C√¢mera Ativa';
            roomIdInput.disabled = true;
            log('‚è≥ Aguardando desktop conectar...');
        };

        async function restartCamera() {
            log('üîÑ Reiniciando c√¢mera e stream...');
            
            const previousZoom = currentZoomLevel;
            
            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
            }
            
            const success = await startCamera();
            
            if (success && videoSender && peerConnection) {
                const newTrack = localStream.getVideoTracks()[0];
                await videoSender.replaceTrack(newTrack);
                videoTrack = newTrack;
                await applyEncoderSettings();
                
                // Reaplicar zoom ap√≥s restart
                setTimeout(() => {
                    applyZoom(previousZoom);
                }, 500);
                
                log('‚úÖ C√¢mera reiniciada com sucesso!');
            } else if (success) {
                // If peerConnection not yet setup, just start camera
                log('‚úÖ C√¢mera iniciada, aguardando PeerConnection.');
            } else {
                log('‚ùå Falha ao reiniciar c√¢mera.');
            }
        }

        restartBtn.onclick = restartCamera;

        [resolutionSelect, bitrateSelect, fpsSelect, cameraSelect].forEach(select => {
            select.addEventListener('change', () => {
                restartBtn.style.background = '#FF9800';
                restartBtn.textContent = 'üîÑ APLICAR MUDAN√áAS';
            });
        });

        function applyCommand(data) {
            if (!videoTrack) {
                log('‚ö†Ô∏è N√£o h√° v√≠deo track para aplicar comando.');
                return;
            }

            const capabilities = videoTrack.getCapabilities();

            if (data.control === 'iso' && capabilities.iso) {
                const val = parseInt(data.value);
                const clamped = Math.max(capabilities.iso.min, Math.min(capabilities.iso.max, val));
                videoTrack.applyConstraints({
                    advanced: [{ iso: clamped }]
                }).then(() => log(`‚úÖ ISO: ${clamped}`)).catch(e => log(`‚ùå Erro ISO: ${e.message}`));
            }

            if (data.control === 'exposure' && capabilities.exposureCompensation) {
                const val = parseFloat(data.value);
                const clamped = Math.max(capabilities.exposureCompensation.min, Math.min(capabilities.exposureCompensation.max, val));
                videoTrack.applyConstraints({
                    advanced: [{ exposureCompensation: clamped }]
                }).then(() => log(`‚úÖ Exposi√ß√£o: ${clamped.toFixed(1)}`)).catch(e => log(`‚ùå Erro Exposi√ß√£o: ${e.message}`));
            }
        }

        // PWA Service Worker registration
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('/service-worker.js')
                .then(() => log('‚úÖ PWA Service Worker registrado.'))
                .catch(e => log('‚ùå Erro ao registrar PWA Service Worker: ' + e.message));
        }

        // Initial camera detection when page loads
        // This will populate the dropdown even before starting the stream
        // detectCameras(); // Moved to startBtn.onclick to ensure permissions are handled correctly
    </script>
</body>
</html>